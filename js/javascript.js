"use strict"

// 1)

let xx = 5 ; alert(xx++);

//Выведет 5 так как это постфиксная форма икремента(вернула исходное значение) , а была бы префиксная - было бы 6.

// 2) [] + false - null + true 

// Выведет NaN так как (динамическая типизация)

// Конкатинация(сложение с пустім массивом всегда даст строку);

// 3) 
      let y = 1;
      let x = y = 2;
      alert(x);

// Выведет 2 так как последивательнон присваивание

// 4) 
     [] + 1 + 2

// Выведет 12 так как все что конкатинируется с пустым массивом превращается в строку.


// 5) 
     alert("1"[0]);
     // Выведет 1 так как индекс еденицы 0 .

// 6)
    console.log(2 && 1 && null && 0 && undefined)
    // Выведет null так как логический оператор && заканчивает свою работу на первой не правде (запинается на лжи).
    // А логический оператор || (или) всегда запинается на правде

// 7) 
     //Есть ли разница? 
    console.log(!!(а && b) === (a && b));
    // Не равны так как !! возвращают выражение в булиновое

// 8) 
     alert (null || 2 && 3 || 4);
      // И (&&) выполняется первее чем || (или) (2 && 3 ) - выведет 3
      // ИЛИ ЗАПИНАЕТСЯ НА ПРАВДЕ
      
      // Выведет 3 так как или запинается на правде.

// 9) 
    const a = [1,2,3];
    const b = [1,2,3];

    // Массивы не одинаковые так как разные переменные (хранилища информации);

// 10) 
   alert(+"Infinitу");
   console.log(+"Infinitу");
   // Выведет Infinity ( тип данных число так как  унарный плюс);

// 11) 

    "Ежик" > "яблоко";

  //Посимвольное сравнение с лева на право.

// 12) 
    (0 || "" || 2 || undefined || true || false);

    // Ответ 2 так как логический оператор || (или) запинается на правде.




     


     